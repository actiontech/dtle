// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: import_sstpb.proto

package import_sstpb

import (
	"fmt"
	"io"
	"math"

	proto "github.com/golang/protobuf/proto"

	_ "github.com/gogo/protobuf/gogoproto"

	brpb "github.com/pingcap/kvproto/pkg/brpb"

	errorpb "github.com/pingcap/kvproto/pkg/errorpb"

	kvrpcpb "github.com/pingcap/kvproto/pkg/kvrpcpb"

	metapb "github.com/pingcap/kvproto/pkg/metapb"

	_ "github.com/pingcap/kvproto/pkg/raft_serverpb"

	context "golang.org/x/net/context"

	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type SwitchMode int32

const (
	SwitchMode_Normal SwitchMode = 0
	SwitchMode_Import SwitchMode = 1
)

var SwitchMode_name = map[int32]string{
	0: "Normal",
	1: "Import",
}
var SwitchMode_value = map[string]int32{
	"Normal": 0,
	"Import": 1,
}

func (x SwitchMode) String() string {
	return proto.EnumName(SwitchMode_name, int32(x))
}
func (SwitchMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{0}
}

type Pair_OP int32

const (
	Pair_Put    Pair_OP = 0
	Pair_Delete Pair_OP = 1
)

var Pair_OP_name = map[int32]string{
	0: "Put",
	1: "Delete",
}
var Pair_OP_value = map[string]int32{
	"Put":    0,
	"Delete": 1,
}

func (x Pair_OP) String() string {
	return proto.EnumName(Pair_OP_name, int32(x))
}
func (Pair_OP) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{17, 0}
}

type SwitchModeRequest struct {
	Mode                 SwitchMode `protobuf:"varint,1,opt,name=mode,proto3,enum=import_sstpb.SwitchMode" json:"mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *SwitchModeRequest) Reset()         { *m = SwitchModeRequest{} }
func (m *SwitchModeRequest) String() string { return proto.CompactTextString(m) }
func (*SwitchModeRequest) ProtoMessage()    {}
func (*SwitchModeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{0}
}
func (m *SwitchModeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwitchModeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwitchModeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SwitchModeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwitchModeRequest.Merge(dst, src)
}
func (m *SwitchModeRequest) XXX_Size() int {
	return m.Size()
}
func (m *SwitchModeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SwitchModeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SwitchModeRequest proto.InternalMessageInfo

func (m *SwitchModeRequest) GetMode() SwitchMode {
	if m != nil {
		return m.Mode
	}
	return SwitchMode_Normal
}

type SwitchModeResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SwitchModeResponse) Reset()         { *m = SwitchModeResponse{} }
func (m *SwitchModeResponse) String() string { return proto.CompactTextString(m) }
func (*SwitchModeResponse) ProtoMessage()    {}
func (*SwitchModeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{1}
}
func (m *SwitchModeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwitchModeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwitchModeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SwitchModeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwitchModeResponse.Merge(dst, src)
}
func (m *SwitchModeResponse) XXX_Size() int {
	return m.Size()
}
func (m *SwitchModeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SwitchModeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SwitchModeResponse proto.InternalMessageInfo

type Range struct {
	Start                []byte   `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
	End                  []byte   `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Range) Reset()         { *m = Range{} }
func (m *Range) String() string { return proto.CompactTextString(m) }
func (*Range) ProtoMessage()    {}
func (*Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{2}
}
func (m *Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Range.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range.Merge(dst, src)
}
func (m *Range) XXX_Size() int {
	return m.Size()
}
func (m *Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Range.DiscardUnknown(m)
}

var xxx_messageInfo_Range proto.InternalMessageInfo

func (m *Range) GetStart() []byte {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *Range) GetEnd() []byte {
	if m != nil {
		return m.End
	}
	return nil
}

type SSTMeta struct {
	Uuid            []byte              `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	Range           *Range              `protobuf:"bytes,2,opt,name=range" json:"range,omitempty"`
	Crc32           uint32              `protobuf:"varint,3,opt,name=crc32,proto3" json:"crc32,omitempty"`
	Length          uint64              `protobuf:"varint,4,opt,name=length,proto3" json:"length,omitempty"`
	CfName          string              `protobuf:"bytes,5,opt,name=cf_name,json=cfName,proto3" json:"cf_name,omitempty"`
	RegionId        uint64              `protobuf:"varint,6,opt,name=region_id,json=regionId,proto3" json:"region_id,omitempty"`
	RegionEpoch     *metapb.RegionEpoch `protobuf:"bytes,7,opt,name=region_epoch,json=regionEpoch" json:"region_epoch,omitempty"`
	EndKeyExclusive bool                `protobuf:"varint,8,opt,name=end_key_exclusive,json=endKeyExclusive,proto3" json:"end_key_exclusive,omitempty"`
	// total_kvs and total_bytes is equivalent to PD's approximate_keys and approximate_size
	// set these values can save time from tikv upload keys and size to PD through Heartbeat.
	TotalKvs   uint64 `protobuf:"varint,9,opt,name=total_kvs,json=totalKvs,proto3" json:"total_kvs,omitempty"`
	TotalBytes uint64 `protobuf:"varint,10,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
	// API version implies the encode of the key and value.
	ApiVersion kvrpcpb.APIVersion `protobuf:"varint,11,opt,name=api_version,json=apiVersion,proto3,enum=kvrpcpb.APIVersion" json:"api_version,omitempty"`
	// cipher_iv is used to encrypt/decrypt sst
	CipherIv             []byte   `protobuf:"bytes,12,opt,name=cipher_iv,json=cipherIv,proto3" json:"cipher_iv,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SSTMeta) Reset()         { *m = SSTMeta{} }
func (m *SSTMeta) String() string { return proto.CompactTextString(m) }
func (*SSTMeta) ProtoMessage()    {}
func (*SSTMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{3}
}
func (m *SSTMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SSTMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SSTMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SSTMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SSTMeta.Merge(dst, src)
}
func (m *SSTMeta) XXX_Size() int {
	return m.Size()
}
func (m *SSTMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_SSTMeta.DiscardUnknown(m)
}

var xxx_messageInfo_SSTMeta proto.InternalMessageInfo

func (m *SSTMeta) GetUuid() []byte {
	if m != nil {
		return m.Uuid
	}
	return nil
}

func (m *SSTMeta) GetRange() *Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *SSTMeta) GetCrc32() uint32 {
	if m != nil {
		return m.Crc32
	}
	return 0
}

func (m *SSTMeta) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *SSTMeta) GetCfName() string {
	if m != nil {
		return m.CfName
	}
	return ""
}

func (m *SSTMeta) GetRegionId() uint64 {
	if m != nil {
		return m.RegionId
	}
	return 0
}

func (m *SSTMeta) GetRegionEpoch() *metapb.RegionEpoch {
	if m != nil {
		return m.RegionEpoch
	}
	return nil
}

func (m *SSTMeta) GetEndKeyExclusive() bool {
	if m != nil {
		return m.EndKeyExclusive
	}
	return false
}

func (m *SSTMeta) GetTotalKvs() uint64 {
	if m != nil {
		return m.TotalKvs
	}
	return 0
}

func (m *SSTMeta) GetTotalBytes() uint64 {
	if m != nil {
		return m.TotalBytes
	}
	return 0
}

func (m *SSTMeta) GetApiVersion() kvrpcpb.APIVersion {
	if m != nil {
		return m.ApiVersion
	}
	return kvrpcpb.APIVersion_V1
}

func (m *SSTMeta) GetCipherIv() []byte {
	if m != nil {
		return m.CipherIv
	}
	return nil
}

// A rewrite rule is applied on the *encoded* keys (the internal storage
// representation).
type RewriteRule struct {
	OldKeyPrefix         []byte   `protobuf:"bytes,1,opt,name=old_key_prefix,json=oldKeyPrefix,proto3" json:"old_key_prefix,omitempty"`
	NewKeyPrefix         []byte   `protobuf:"bytes,2,opt,name=new_key_prefix,json=newKeyPrefix,proto3" json:"new_key_prefix,omitempty"`
	NewTimestamp         uint64   `protobuf:"varint,3,opt,name=new_timestamp,json=newTimestamp,proto3" json:"new_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RewriteRule) Reset()         { *m = RewriteRule{} }
func (m *RewriteRule) String() string { return proto.CompactTextString(m) }
func (*RewriteRule) ProtoMessage()    {}
func (*RewriteRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{4}
}
func (m *RewriteRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewriteRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewriteRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RewriteRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewriteRule.Merge(dst, src)
}
func (m *RewriteRule) XXX_Size() int {
	return m.Size()
}
func (m *RewriteRule) XXX_DiscardUnknown() {
	xxx_messageInfo_RewriteRule.DiscardUnknown(m)
}

var xxx_messageInfo_RewriteRule proto.InternalMessageInfo

func (m *RewriteRule) GetOldKeyPrefix() []byte {
	if m != nil {
		return m.OldKeyPrefix
	}
	return nil
}

func (m *RewriteRule) GetNewKeyPrefix() []byte {
	if m != nil {
		return m.NewKeyPrefix
	}
	return nil
}

func (m *RewriteRule) GetNewTimestamp() uint64 {
	if m != nil {
		return m.NewTimestamp
	}
	return 0
}

type UploadRequest struct {
	// Types that are valid to be assigned to Chunk:
	//	*UploadRequest_Meta
	//	*UploadRequest_Data
	Chunk                isUploadRequest_Chunk `protobuf_oneof:"chunk"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *UploadRequest) Reset()         { *m = UploadRequest{} }
func (m *UploadRequest) String() string { return proto.CompactTextString(m) }
func (*UploadRequest) ProtoMessage()    {}
func (*UploadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{5}
}
func (m *UploadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UploadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadRequest.Merge(dst, src)
}
func (m *UploadRequest) XXX_Size() int {
	return m.Size()
}
func (m *UploadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadRequest proto.InternalMessageInfo

type isUploadRequest_Chunk interface {
	isUploadRequest_Chunk()
	MarshalTo([]byte) (int, error)
	Size() int
}

type UploadRequest_Meta struct {
	Meta *SSTMeta `protobuf:"bytes,1,opt,name=meta,oneof"`
}
type UploadRequest_Data struct {
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3,oneof"`
}

func (*UploadRequest_Meta) isUploadRequest_Chunk() {}
func (*UploadRequest_Data) isUploadRequest_Chunk() {}

func (m *UploadRequest) GetChunk() isUploadRequest_Chunk {
	if m != nil {
		return m.Chunk
	}
	return nil
}

func (m *UploadRequest) GetMeta() *SSTMeta {
	if x, ok := m.GetChunk().(*UploadRequest_Meta); ok {
		return x.Meta
	}
	return nil
}

func (m *UploadRequest) GetData() []byte {
	if x, ok := m.GetChunk().(*UploadRequest_Data); ok {
		return x.Data
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*UploadRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _UploadRequest_OneofMarshaler, _UploadRequest_OneofUnmarshaler, _UploadRequest_OneofSizer, []interface{}{
		(*UploadRequest_Meta)(nil),
		(*UploadRequest_Data)(nil),
	}
}

func _UploadRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*UploadRequest)
	// chunk
	switch x := m.Chunk.(type) {
	case *UploadRequest_Meta:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Meta); err != nil {
			return err
		}
	case *UploadRequest_Data:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeRawBytes(x.Data)
	case nil:
	default:
		return fmt.Errorf("UploadRequest.Chunk has unexpected type %T", x)
	}
	return nil
}

func _UploadRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*UploadRequest)
	switch tag {
	case 1: // chunk.meta
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SSTMeta)
		err := b.DecodeMessage(msg)
		m.Chunk = &UploadRequest_Meta{msg}
		return true, err
	case 2: // chunk.data
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.Chunk = &UploadRequest_Data{x}
		return true, err
	default:
		return false, nil
	}
}

func _UploadRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*UploadRequest)
	// chunk
	switch x := m.Chunk.(type) {
	case *UploadRequest_Meta:
		s := proto.Size(x.Meta)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *UploadRequest_Data:
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(len(x.Data)))
		n += len(x.Data)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type UploadResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadResponse) Reset()         { *m = UploadResponse{} }
func (m *UploadResponse) String() string { return proto.CompactTextString(m) }
func (*UploadResponse) ProtoMessage()    {}
func (*UploadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{6}
}
func (m *UploadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UploadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadResponse.Merge(dst, src)
}
func (m *UploadResponse) XXX_Size() int {
	return m.Size()
}
func (m *UploadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UploadResponse proto.InternalMessageInfo

type IngestRequest struct {
	Context              *kvrpcpb.Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Sst                  *SSTMeta         `protobuf:"bytes,2,opt,name=sst" json:"sst,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *IngestRequest) Reset()         { *m = IngestRequest{} }
func (m *IngestRequest) String() string { return proto.CompactTextString(m) }
func (*IngestRequest) ProtoMessage()    {}
func (*IngestRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{7}
}
func (m *IngestRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngestRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngestRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IngestRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngestRequest.Merge(dst, src)
}
func (m *IngestRequest) XXX_Size() int {
	return m.Size()
}
func (m *IngestRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_IngestRequest.DiscardUnknown(m)
}

var xxx_messageInfo_IngestRequest proto.InternalMessageInfo

func (m *IngestRequest) GetContext() *kvrpcpb.Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *IngestRequest) GetSst() *SSTMeta {
	if m != nil {
		return m.Sst
	}
	return nil
}

type MultiIngestRequest struct {
	Context              *kvrpcpb.Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Ssts                 []*SSTMeta       `protobuf:"bytes,2,rep,name=ssts" json:"ssts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *MultiIngestRequest) Reset()         { *m = MultiIngestRequest{} }
func (m *MultiIngestRequest) String() string { return proto.CompactTextString(m) }
func (*MultiIngestRequest) ProtoMessage()    {}
func (*MultiIngestRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{8}
}
func (m *MultiIngestRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiIngestRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiIngestRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MultiIngestRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiIngestRequest.Merge(dst, src)
}
func (m *MultiIngestRequest) XXX_Size() int {
	return m.Size()
}
func (m *MultiIngestRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiIngestRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MultiIngestRequest proto.InternalMessageInfo

func (m *MultiIngestRequest) GetContext() *kvrpcpb.Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *MultiIngestRequest) GetSsts() []*SSTMeta {
	if m != nil {
		return m.Ssts
	}
	return nil
}

type IngestResponse struct {
	Error                *errorpb.Error `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *IngestResponse) Reset()         { *m = IngestResponse{} }
func (m *IngestResponse) String() string { return proto.CompactTextString(m) }
func (*IngestResponse) ProtoMessage()    {}
func (*IngestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{9}
}
func (m *IngestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IngestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IngestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *IngestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IngestResponse.Merge(dst, src)
}
func (m *IngestResponse) XXX_Size() int {
	return m.Size()
}
func (m *IngestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_IngestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_IngestResponse proto.InternalMessageInfo

func (m *IngestResponse) GetError() *errorpb.Error {
	if m != nil {
		return m.Error
	}
	return nil
}

type CompactRequest struct {
	// Compact files in the range and above the output level.
	// Compact all files if the range is not specified.
	// Compact all files to the bottommost level if the output level is -1.
	Range                *Range   `protobuf:"bytes,1,opt,name=range" json:"range,omitempty"`
	OutputLevel          int32    `protobuf:"varint,2,opt,name=output_level,json=outputLevel,proto3" json:"output_level,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CompactRequest) Reset()         { *m = CompactRequest{} }
func (m *CompactRequest) String() string { return proto.CompactTextString(m) }
func (*CompactRequest) ProtoMessage()    {}
func (*CompactRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{10}
}
func (m *CompactRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CompactRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactRequest.Merge(dst, src)
}
func (m *CompactRequest) XXX_Size() int {
	return m.Size()
}
func (m *CompactRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CompactRequest proto.InternalMessageInfo

func (m *CompactRequest) GetRange() *Range {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *CompactRequest) GetOutputLevel() int32 {
	if m != nil {
		return m.OutputLevel
	}
	return 0
}

type CompactResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CompactResponse) Reset()         { *m = CompactResponse{} }
func (m *CompactResponse) String() string { return proto.CompactTextString(m) }
func (*CompactResponse) ProtoMessage()    {}
func (*CompactResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{11}
}
func (m *CompactResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *CompactResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactResponse.Merge(dst, src)
}
func (m *CompactResponse) XXX_Size() int {
	return m.Size()
}
func (m *CompactResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CompactResponse proto.InternalMessageInfo

type DownloadRequest struct {
	// The SST meta used to identify the downloaded file.
	// Must be the same among all nodes in the same Raft group.
	// Note: the "crc32" and "cf_name" fields are ignored in this request,
	// and the "range" field represents the closed key range after rewrite
	// (as origin keys in encoded representation).
	Sst SSTMeta `protobuf:"bytes,2,opt,name=sst" json:"sst"`
	// The file name of the SST file.
	Name string `protobuf:"bytes,9,opt,name=name,proto3" json:"name,omitempty"`
	// Performs a key prefix rewrite after downloading the SST file.
	// All keys in the SST will be rewritten as:
	//
	//  new_key = new_key_prefix + old_key[len(old_key_prefix)..]
	//
	// When used for TiDB, rewriting the prefix changes the table ID. Please
	// note that key-rewrite is applied on the origin keys in encoded
	// representation (the SST itself should still use data keys in encoded
	// representation).
	//
	// You need to ensure that the keys before and after rewriting are in the
	// same order, otherwise the RPC request will fail.
	RewriteRule    RewriteRule          `protobuf:"bytes,13,opt,name=rewrite_rule,json=rewriteRule" json:"rewrite_rule"`
	StorageBackend *brpb.StorageBackend `protobuf:"bytes,14,opt,name=storage_backend,json=storageBackend" json:"storage_backend,omitempty"`
	IsRawKv        bool                 `protobuf:"varint,15,opt,name=is_raw_kv,json=isRawKv,proto3" json:"is_raw_kv,omitempty"`
	// cipher_info is used to decrypt sst when download sst
	CipherInfo           *brpb.CipherInfo `protobuf:"bytes,16,opt,name=cipher_info,json=cipherInfo" json:"cipher_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *DownloadRequest) Reset()         { *m = DownloadRequest{} }
func (m *DownloadRequest) String() string { return proto.CompactTextString(m) }
func (*DownloadRequest) ProtoMessage()    {}
func (*DownloadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{12}
}
func (m *DownloadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DownloadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadRequest.Merge(dst, src)
}
func (m *DownloadRequest) XXX_Size() int {
	return m.Size()
}
func (m *DownloadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadRequest proto.InternalMessageInfo

func (m *DownloadRequest) GetSst() SSTMeta {
	if m != nil {
		return m.Sst
	}
	return SSTMeta{}
}

func (m *DownloadRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DownloadRequest) GetRewriteRule() RewriteRule {
	if m != nil {
		return m.RewriteRule
	}
	return RewriteRule{}
}

func (m *DownloadRequest) GetStorageBackend() *brpb.StorageBackend {
	if m != nil {
		return m.StorageBackend
	}
	return nil
}

func (m *DownloadRequest) GetIsRawKv() bool {
	if m != nil {
		return m.IsRawKv
	}
	return false
}

func (m *DownloadRequest) GetCipherInfo() *brpb.CipherInfo {
	if m != nil {
		return m.CipherInfo
	}
	return nil
}

// For now it is just used for distinguishing the error of the request with the error
// of gRPC, add more concrete types if it is necessary later.
type Error struct {
	Message              string   `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Error) Reset()         { *m = Error{} }
func (m *Error) String() string { return proto.CompactTextString(m) }
func (*Error) ProtoMessage()    {}
func (*Error) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{13}
}
func (m *Error) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Error) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Error.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Error) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Error.Merge(dst, src)
}
func (m *Error) XXX_Size() int {
	return m.Size()
}
func (m *Error) XXX_DiscardUnknown() {
	xxx_messageInfo_Error.DiscardUnknown(m)
}

var xxx_messageInfo_Error proto.InternalMessageInfo

func (m *Error) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type DownloadResponse struct {
	// The actual key range (after rewrite) of the downloaded SST. The range is
	// inclusive in both ends.
	Range Range `protobuf:"bytes,1,opt,name=range" json:"range"`
	// Whether the SST is empty. An empty SST is prohibited in TiKV, do not
	// ingest if this field is true.
	// (Deprecated, should be replaced by checking `length == 0` in the future)
	IsEmpty bool   `protobuf:"varint,2,opt,name=is_empty,json=isEmpty,proto3" json:"is_empty,omitempty"`
	Error   *Error `protobuf:"bytes,3,opt,name=error" json:"error,omitempty"`
	// The CRC32 checksum of the rewritten SST file (implementation can return
	// zero, indicating the CRC32 was not calculated).
	Crc32 uint32 `protobuf:"varint,4,opt,name=crc32,proto3" json:"crc32,omitempty"`
	// The actual length of the rewritten SST file.
	Length               uint64   `protobuf:"varint,5,opt,name=length,proto3" json:"length,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DownloadResponse) Reset()         { *m = DownloadResponse{} }
func (m *DownloadResponse) String() string { return proto.CompactTextString(m) }
func (*DownloadResponse) ProtoMessage()    {}
func (*DownloadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{14}
}
func (m *DownloadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DownloadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DownloadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DownloadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DownloadResponse.Merge(dst, src)
}
func (m *DownloadResponse) XXX_Size() int {
	return m.Size()
}
func (m *DownloadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DownloadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DownloadResponse proto.InternalMessageInfo

func (m *DownloadResponse) GetRange() Range {
	if m != nil {
		return m.Range
	}
	return Range{}
}

func (m *DownloadResponse) GetIsEmpty() bool {
	if m != nil {
		return m.IsEmpty
	}
	return false
}

func (m *DownloadResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *DownloadResponse) GetCrc32() uint32 {
	if m != nil {
		return m.Crc32
	}
	return 0
}

func (m *DownloadResponse) GetLength() uint64 {
	if m != nil {
		return m.Length
	}
	return 0
}

type SetDownloadSpeedLimitRequest struct {
	// The download speed limit (bytes/second). Set to 0 for unlimited speed.
	SpeedLimit           uint64   `protobuf:"varint,1,opt,name=speed_limit,json=speedLimit,proto3" json:"speed_limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetDownloadSpeedLimitRequest) Reset()         { *m = SetDownloadSpeedLimitRequest{} }
func (m *SetDownloadSpeedLimitRequest) String() string { return proto.CompactTextString(m) }
func (*SetDownloadSpeedLimitRequest) ProtoMessage()    {}
func (*SetDownloadSpeedLimitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{15}
}
func (m *SetDownloadSpeedLimitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetDownloadSpeedLimitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetDownloadSpeedLimitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SetDownloadSpeedLimitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetDownloadSpeedLimitRequest.Merge(dst, src)
}
func (m *SetDownloadSpeedLimitRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetDownloadSpeedLimitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetDownloadSpeedLimitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetDownloadSpeedLimitRequest proto.InternalMessageInfo

func (m *SetDownloadSpeedLimitRequest) GetSpeedLimit() uint64 {
	if m != nil {
		return m.SpeedLimit
	}
	return 0
}

type SetDownloadSpeedLimitResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetDownloadSpeedLimitResponse) Reset()         { *m = SetDownloadSpeedLimitResponse{} }
func (m *SetDownloadSpeedLimitResponse) String() string { return proto.CompactTextString(m) }
func (*SetDownloadSpeedLimitResponse) ProtoMessage()    {}
func (*SetDownloadSpeedLimitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{16}
}
func (m *SetDownloadSpeedLimitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetDownloadSpeedLimitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetDownloadSpeedLimitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SetDownloadSpeedLimitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetDownloadSpeedLimitResponse.Merge(dst, src)
}
func (m *SetDownloadSpeedLimitResponse) XXX_Size() int {
	return m.Size()
}
func (m *SetDownloadSpeedLimitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SetDownloadSpeedLimitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SetDownloadSpeedLimitResponse proto.InternalMessageInfo

type Pair struct {
	Key                  []byte   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                []byte   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Op                   Pair_OP  `protobuf:"varint,3,opt,name=op,proto3,enum=import_sstpb.Pair_OP" json:"op,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Pair) Reset()         { *m = Pair{} }
func (m *Pair) String() string { return proto.CompactTextString(m) }
func (*Pair) ProtoMessage()    {}
func (*Pair) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{17}
}
func (m *Pair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Pair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pair.Merge(dst, src)
}
func (m *Pair) XXX_Size() int {
	return m.Size()
}
func (m *Pair) XXX_DiscardUnknown() {
	xxx_messageInfo_Pair.DiscardUnknown(m)
}

var xxx_messageInfo_Pair proto.InternalMessageInfo

func (m *Pair) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Pair) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Pair) GetOp() Pair_OP {
	if m != nil {
		return m.Op
	}
	return Pair_Put
}

type WriteBatch struct {
	CommitTs             uint64   `protobuf:"varint,1,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	Pairs                []*Pair  `protobuf:"bytes,2,rep,name=pairs" json:"pairs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WriteBatch) Reset()         { *m = WriteBatch{} }
func (m *WriteBatch) String() string { return proto.CompactTextString(m) }
func (*WriteBatch) ProtoMessage()    {}
func (*WriteBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{18}
}
func (m *WriteBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WriteBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteBatch.Merge(dst, src)
}
func (m *WriteBatch) XXX_Size() int {
	return m.Size()
}
func (m *WriteBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteBatch.DiscardUnknown(m)
}

var xxx_messageInfo_WriteBatch proto.InternalMessageInfo

func (m *WriteBatch) GetCommitTs() uint64 {
	if m != nil {
		return m.CommitTs
	}
	return 0
}

func (m *WriteBatch) GetPairs() []*Pair {
	if m != nil {
		return m.Pairs
	}
	return nil
}

type WriteRequest struct {
	// Types that are valid to be assigned to Chunk:
	//	*WriteRequest_Meta
	//	*WriteRequest_Batch
	Chunk                isWriteRequest_Chunk `protobuf_oneof:"chunk"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *WriteRequest) Reset()         { *m = WriteRequest{} }
func (m *WriteRequest) String() string { return proto.CompactTextString(m) }
func (*WriteRequest) ProtoMessage()    {}
func (*WriteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{19}
}
func (m *WriteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WriteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteRequest.Merge(dst, src)
}
func (m *WriteRequest) XXX_Size() int {
	return m.Size()
}
func (m *WriteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WriteRequest proto.InternalMessageInfo

type isWriteRequest_Chunk interface {
	isWriteRequest_Chunk()
	MarshalTo([]byte) (int, error)
	Size() int
}

type WriteRequest_Meta struct {
	Meta *SSTMeta `protobuf:"bytes,1,opt,name=meta,oneof"`
}
type WriteRequest_Batch struct {
	Batch *WriteBatch `protobuf:"bytes,2,opt,name=batch,oneof"`
}

func (*WriteRequest_Meta) isWriteRequest_Chunk()  {}
func (*WriteRequest_Batch) isWriteRequest_Chunk() {}

func (m *WriteRequest) GetChunk() isWriteRequest_Chunk {
	if m != nil {
		return m.Chunk
	}
	return nil
}

func (m *WriteRequest) GetMeta() *SSTMeta {
	if x, ok := m.GetChunk().(*WriteRequest_Meta); ok {
		return x.Meta
	}
	return nil
}

func (m *WriteRequest) GetBatch() *WriteBatch {
	if x, ok := m.GetChunk().(*WriteRequest_Batch); ok {
		return x.Batch
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*WriteRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _WriteRequest_OneofMarshaler, _WriteRequest_OneofUnmarshaler, _WriteRequest_OneofSizer, []interface{}{
		(*WriteRequest_Meta)(nil),
		(*WriteRequest_Batch)(nil),
	}
}

func _WriteRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*WriteRequest)
	// chunk
	switch x := m.Chunk.(type) {
	case *WriteRequest_Meta:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Meta); err != nil {
			return err
		}
	case *WriteRequest_Batch:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Batch); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("WriteRequest.Chunk has unexpected type %T", x)
	}
	return nil
}

func _WriteRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*WriteRequest)
	switch tag {
	case 1: // chunk.meta
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SSTMeta)
		err := b.DecodeMessage(msg)
		m.Chunk = &WriteRequest_Meta{msg}
		return true, err
	case 2: // chunk.batch
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(WriteBatch)
		err := b.DecodeMessage(msg)
		m.Chunk = &WriteRequest_Batch{msg}
		return true, err
	default:
		return false, nil
	}
}

func _WriteRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*WriteRequest)
	// chunk
	switch x := m.Chunk.(type) {
	case *WriteRequest_Meta:
		s := proto.Size(x.Meta)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *WriteRequest_Batch:
		s := proto.Size(x.Batch)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type WriteResponse struct {
	Error                *Error     `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	Metas                []*SSTMeta `protobuf:"bytes,2,rep,name=metas" json:"metas,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *WriteResponse) Reset()         { *m = WriteResponse{} }
func (m *WriteResponse) String() string { return proto.CompactTextString(m) }
func (*WriteResponse) ProtoMessage()    {}
func (*WriteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{20}
}
func (m *WriteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WriteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WriteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *WriteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WriteResponse.Merge(dst, src)
}
func (m *WriteResponse) XXX_Size() int {
	return m.Size()
}
func (m *WriteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_WriteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_WriteResponse proto.InternalMessageInfo

func (m *WriteResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *WriteResponse) GetMetas() []*SSTMeta {
	if m != nil {
		return m.Metas
	}
	return nil
}

type RawWriteBatch struct {
	Ttl                  uint64   `protobuf:"varint,1,opt,name=ttl,proto3" json:"ttl,omitempty"`
	Pairs                []*Pair  `protobuf:"bytes,2,rep,name=pairs" json:"pairs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RawWriteBatch) Reset()         { *m = RawWriteBatch{} }
func (m *RawWriteBatch) String() string { return proto.CompactTextString(m) }
func (*RawWriteBatch) ProtoMessage()    {}
func (*RawWriteBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{21}
}
func (m *RawWriteBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawWriteBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawWriteBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RawWriteBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawWriteBatch.Merge(dst, src)
}
func (m *RawWriteBatch) XXX_Size() int {
	return m.Size()
}
func (m *RawWriteBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RawWriteBatch.DiscardUnknown(m)
}

var xxx_messageInfo_RawWriteBatch proto.InternalMessageInfo

func (m *RawWriteBatch) GetTtl() uint64 {
	if m != nil {
		return m.Ttl
	}
	return 0
}

func (m *RawWriteBatch) GetPairs() []*Pair {
	if m != nil {
		return m.Pairs
	}
	return nil
}

type RawWriteRequest struct {
	// Types that are valid to be assigned to Chunk:
	//	*RawWriteRequest_Meta
	//	*RawWriteRequest_Batch
	Chunk                isRawWriteRequest_Chunk `protobuf_oneof:"chunk"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *RawWriteRequest) Reset()         { *m = RawWriteRequest{} }
func (m *RawWriteRequest) String() string { return proto.CompactTextString(m) }
func (*RawWriteRequest) ProtoMessage()    {}
func (*RawWriteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{22}
}
func (m *RawWriteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawWriteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawWriteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RawWriteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawWriteRequest.Merge(dst, src)
}
func (m *RawWriteRequest) XXX_Size() int {
	return m.Size()
}
func (m *RawWriteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RawWriteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RawWriteRequest proto.InternalMessageInfo

type isRawWriteRequest_Chunk interface {
	isRawWriteRequest_Chunk()
	MarshalTo([]byte) (int, error)
	Size() int
}

type RawWriteRequest_Meta struct {
	Meta *SSTMeta `protobuf:"bytes,1,opt,name=meta,oneof"`
}
type RawWriteRequest_Batch struct {
	Batch *RawWriteBatch `protobuf:"bytes,2,opt,name=batch,oneof"`
}

func (*RawWriteRequest_Meta) isRawWriteRequest_Chunk()  {}
func (*RawWriteRequest_Batch) isRawWriteRequest_Chunk() {}

func (m *RawWriteRequest) GetChunk() isRawWriteRequest_Chunk {
	if m != nil {
		return m.Chunk
	}
	return nil
}

func (m *RawWriteRequest) GetMeta() *SSTMeta {
	if x, ok := m.GetChunk().(*RawWriteRequest_Meta); ok {
		return x.Meta
	}
	return nil
}

func (m *RawWriteRequest) GetBatch() *RawWriteBatch {
	if x, ok := m.GetChunk().(*RawWriteRequest_Batch); ok {
		return x.Batch
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RawWriteRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RawWriteRequest_OneofMarshaler, _RawWriteRequest_OneofUnmarshaler, _RawWriteRequest_OneofSizer, []interface{}{
		(*RawWriteRequest_Meta)(nil),
		(*RawWriteRequest_Batch)(nil),
	}
}

func _RawWriteRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RawWriteRequest)
	// chunk
	switch x := m.Chunk.(type) {
	case *RawWriteRequest_Meta:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Meta); err != nil {
			return err
		}
	case *RawWriteRequest_Batch:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Batch); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RawWriteRequest.Chunk has unexpected type %T", x)
	}
	return nil
}

func _RawWriteRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RawWriteRequest)
	switch tag {
	case 1: // chunk.meta
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SSTMeta)
		err := b.DecodeMessage(msg)
		m.Chunk = &RawWriteRequest_Meta{msg}
		return true, err
	case 2: // chunk.batch
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RawWriteBatch)
		err := b.DecodeMessage(msg)
		m.Chunk = &RawWriteRequest_Batch{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RawWriteRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RawWriteRequest)
	// chunk
	switch x := m.Chunk.(type) {
	case *RawWriteRequest_Meta:
		s := proto.Size(x.Meta)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RawWriteRequest_Batch:
		s := proto.Size(x.Batch)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type RawWriteResponse struct {
	Error                *Error     `protobuf:"bytes,1,opt,name=error" json:"error,omitempty"`
	Metas                []*SSTMeta `protobuf:"bytes,2,rep,name=metas" json:"metas,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RawWriteResponse) Reset()         { *m = RawWriteResponse{} }
func (m *RawWriteResponse) String() string { return proto.CompactTextString(m) }
func (*RawWriteResponse) ProtoMessage()    {}
func (*RawWriteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{23}
}
func (m *RawWriteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawWriteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawWriteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RawWriteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawWriteResponse.Merge(dst, src)
}
func (m *RawWriteResponse) XXX_Size() int {
	return m.Size()
}
func (m *RawWriteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RawWriteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RawWriteResponse proto.InternalMessageInfo

func (m *RawWriteResponse) GetError() *Error {
	if m != nil {
		return m.Error
	}
	return nil
}

func (m *RawWriteResponse) GetMetas() []*SSTMeta {
	if m != nil {
		return m.Metas
	}
	return nil
}

type DuplicateDetectRequest struct {
	Context  *kvrpcpb.Context `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	StartKey []byte           `protobuf:"bytes,2,opt,name=start_key,json=startKey,proto3" json:"start_key,omitempty"`
	EndKey   []byte           `protobuf:"bytes,3,opt,name=end_key,json=endKey,proto3" json:"end_key,omitempty"`
	// Return only the keys found by scanning, not their values.
	KeyOnly bool `protobuf:"varint,4,opt,name=key_only,json=keyOnly,proto3" json:"key_only,omitempty"`
	// We only check the data whose timestamp is larger than `min_commit_ts`. `min_commit_ts` is exclueded.
	MinCommitTs          uint64   `protobuf:"varint,5,opt,name=min_commit_ts,json=minCommitTs,proto3" json:"min_commit_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DuplicateDetectRequest) Reset()         { *m = DuplicateDetectRequest{} }
func (m *DuplicateDetectRequest) String() string { return proto.CompactTextString(m) }
func (*DuplicateDetectRequest) ProtoMessage()    {}
func (*DuplicateDetectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{24}
}
func (m *DuplicateDetectRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DuplicateDetectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DuplicateDetectRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DuplicateDetectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DuplicateDetectRequest.Merge(dst, src)
}
func (m *DuplicateDetectRequest) XXX_Size() int {
	return m.Size()
}
func (m *DuplicateDetectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DuplicateDetectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DuplicateDetectRequest proto.InternalMessageInfo

func (m *DuplicateDetectRequest) GetContext() *kvrpcpb.Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *DuplicateDetectRequest) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *DuplicateDetectRequest) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *DuplicateDetectRequest) GetKeyOnly() bool {
	if m != nil {
		return m.KeyOnly
	}
	return false
}

func (m *DuplicateDetectRequest) GetMinCommitTs() uint64 {
	if m != nil {
		return m.MinCommitTs
	}
	return 0
}

type KvPair struct {
	Key                  []byte   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                []byte   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	CommitTs             uint64   `protobuf:"varint,3,opt,name=commit_ts,json=commitTs,proto3" json:"commit_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KvPair) Reset()         { *m = KvPair{} }
func (m *KvPair) String() string { return proto.CompactTextString(m) }
func (*KvPair) ProtoMessage()    {}
func (*KvPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{25}
}
func (m *KvPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KvPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KvPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *KvPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KvPair.Merge(dst, src)
}
func (m *KvPair) XXX_Size() int {
	return m.Size()
}
func (m *KvPair) XXX_DiscardUnknown() {
	xxx_messageInfo_KvPair.DiscardUnknown(m)
}

var xxx_messageInfo_KvPair proto.InternalMessageInfo

func (m *KvPair) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *KvPair) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *KvPair) GetCommitTs() uint64 {
	if m != nil {
		return m.CommitTs
	}
	return 0
}

type DuplicateDetectResponse struct {
	RegionError *errorpb.Error `protobuf:"bytes,1,opt,name=region_error,json=regionError" json:"region_error,omitempty"`
	KeyError    *Error         `protobuf:"bytes,2,opt,name=key_error,json=keyError" json:"key_error,omitempty"`
	// The these keys will be in asc order (but commit time is in desc order),
	//  and the content is just like following:
	// [
	//   {key: "key1", value: "value11", commit_ts: 1005},
	//   {key: "key1", value: "value12", commit_ts: 1004},
	//   {key: "key1", value: "value13", commit_ts: 1001},
	//   {key: "key2", value: "value21", commit_ts: 1004},
	//   {key: "key2", value: "value22", commit_ts: 1002},
	//   ...
	// ]
	Pairs                []*KvPair `protobuf:"bytes,3,rep,name=pairs" json:"pairs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *DuplicateDetectResponse) Reset()         { *m = DuplicateDetectResponse{} }
func (m *DuplicateDetectResponse) String() string { return proto.CompactTextString(m) }
func (*DuplicateDetectResponse) ProtoMessage()    {}
func (*DuplicateDetectResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_import_sstpb_84cbfa235a106715, []int{26}
}
func (m *DuplicateDetectResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DuplicateDetectResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DuplicateDetectResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DuplicateDetectResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DuplicateDetectResponse.Merge(dst, src)
}
func (m *DuplicateDetectResponse) XXX_Size() int {
	return m.Size()
}
func (m *DuplicateDetectResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DuplicateDetectResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DuplicateDetectResponse proto.InternalMessageInfo

func (m *DuplicateDetectResponse) GetRegionError() *errorpb.Error {
	if m != nil {
		return m.RegionError
	}
	return nil
}

func (m *DuplicateDetectResponse) GetKeyError() *Error {
	if m != nil {
		return m.KeyError
	}
	return nil
}

func (m *DuplicateDetectResponse) GetPairs() []*KvPair {
	if m != nil {
		return m.Pairs
	}
	return nil
}

func init() {
	proto.RegisterType((*SwitchModeRequest)(nil), "import_sstpb.SwitchModeRequest")
	proto.RegisterType((*SwitchModeResponse)(nil), "import_sstpb.SwitchModeResponse")
	proto.RegisterType((*Range)(nil), "import_sstpb.Range")
	proto.RegisterType((*SSTMeta)(nil), "import_sstpb.SSTMeta")
	proto.RegisterType((*RewriteRule)(nil), "import_sstpb.RewriteRule")
	proto.RegisterType((*UploadRequest)(nil), "import_sstpb.UploadRequest")
	proto.RegisterType((*UploadResponse)(nil), "import_sstpb.UploadResponse")
	proto.RegisterType((*IngestRequest)(nil), "import_sstpb.IngestRequest")
	proto.RegisterType((*MultiIngestRequest)(nil), "import_sstpb.MultiIngestRequest")
	proto.RegisterType((*IngestResponse)(nil), "import_sstpb.IngestResponse")
	proto.RegisterType((*CompactRequest)(nil), "import_sstpb.CompactRequest")
	proto.RegisterType((*CompactResponse)(nil), "import_sstpb.CompactResponse")
	proto.RegisterType((*DownloadRequest)(nil), "import_sstpb.DownloadRequest")
	proto.RegisterType((*Error)(nil), "import_sstpb.Error")
	proto.RegisterType((*DownloadResponse)(nil), "import_sstpb.DownloadResponse")
	proto.RegisterType((*SetDownloadSpeedLimitRequest)(nil), "import_sstpb.SetDownloadSpeedLimitRequest")
	proto.RegisterType((*SetDownloadSpeedLimitResponse)(nil), "import_sstpb.SetDownloadSpeedLimitResponse")
	proto.RegisterType((*Pair)(nil), "import_sstpb.Pair")
	proto.RegisterType((*WriteBatch)(nil), "import_sstpb.WriteBatch")
	proto.RegisterType((*WriteRequest)(nil), "import_sstpb.WriteRequest")
	proto.RegisterType((*WriteResponse)(nil), "import_sstpb.WriteResponse")
	proto.RegisterType((*RawWriteBatch)(nil), "import_sstpb.RawWriteBatch")
	proto.RegisterType((*RawWriteRequest)(nil), "import_sstpb.RawWriteRequest")
	proto.RegisterType((*RawWriteResponse)(nil), "import_sstpb.RawWriteResponse")
	proto.RegisterType((*DuplicateDetectRequest)(nil), "import_sstpb.DuplicateDetectRequest")
	proto.RegisterType((*KvPair)(nil), "import_sstpb.KvPair")
	proto.RegisterType((*DuplicateDetectResponse)(nil), "import_sstpb.DuplicateDetectResponse")
	proto.RegisterEnum("import_sstpb.SwitchMode", SwitchMode_name, SwitchMode_value)
	proto.RegisterEnum("import_sstpb.Pair_OP", Pair_OP_name, Pair_OP_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ImportSST service

type ImportSSTClient interface {
	// Switch to normal/import mode.
	SwitchMode(ctx context.Context, in *SwitchModeRequest, opts ...grpc.CallOption) (*SwitchModeResponse, error)
	// Upload an SST file to a server.
	Upload(ctx context.Context, opts ...grpc.CallOption) (ImportSST_UploadClient, error)
	// Ingest an uploaded SST file to a region.
	Ingest(ctx context.Context, in *IngestRequest, opts ...grpc.CallOption) (*IngestResponse, error)
	// Compact the specific range for better performance.
	Compact(ctx context.Context, in *CompactRequest, opts ...grpc.CallOption) (*CompactResponse, error)
	SetDownloadSpeedLimit(ctx context.Context, in *SetDownloadSpeedLimitRequest, opts ...grpc.CallOption) (*SetDownloadSpeedLimitResponse, error)
	// Download an SST file from an external storage, and performs key-rewrite
	// after downloading.
	Download(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (*DownloadResponse, error)
	// Open a write stream to generate sst files
	Write(ctx context.Context, opts ...grpc.CallOption) (ImportSST_WriteClient, error)
	RawWrite(ctx context.Context, opts ...grpc.CallOption) (ImportSST_RawWriteClient, error)
	// Ingest Multiple files in one request
	MultiIngest(ctx context.Context, in *MultiIngestRequest, opts ...grpc.CallOption) (*IngestResponse, error)
	// Collect duplicate data from TiKV.
	DuplicateDetect(ctx context.Context, in *DuplicateDetectRequest, opts ...grpc.CallOption) (ImportSST_DuplicateDetectClient, error)
}

type importSSTClient struct {
	cc *grpc.ClientConn
}

func NewImportSSTClient(cc *grpc.ClientConn) ImportSSTClient {
	return &importSSTClient{cc}
}

func (c *importSSTClient) SwitchMode(ctx context.Context, in *SwitchModeRequest, opts ...grpc.CallOption) (*SwitchModeResponse, error) {
	out := new(SwitchModeResponse)
	err := c.cc.Invoke(ctx, "/import_sstpb.ImportSST/SwitchMode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) Upload(ctx context.Context, opts ...grpc.CallOption) (ImportSST_UploadClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ImportSST_serviceDesc.Streams[0], "/import_sstpb.ImportSST/Upload", opts...)
	if err != nil {
		return nil, err
	}
	x := &importSSTUploadClient{stream}
	return x, nil
}

type ImportSST_UploadClient interface {
	Send(*UploadRequest) error
	CloseAndRecv() (*UploadResponse, error)
	grpc.ClientStream
}

type importSSTUploadClient struct {
	grpc.ClientStream
}

func (x *importSSTUploadClient) Send(m *UploadRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *importSSTUploadClient) CloseAndRecv() (*UploadResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(UploadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *importSSTClient) Ingest(ctx context.Context, in *IngestRequest, opts ...grpc.CallOption) (*IngestResponse, error) {
	out := new(IngestResponse)
	err := c.cc.Invoke(ctx, "/import_sstpb.ImportSST/Ingest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) Compact(ctx context.Context, in *CompactRequest, opts ...grpc.CallOption) (*CompactResponse, error) {
	out := new(CompactResponse)
	err := c.cc.Invoke(ctx, "/import_sstpb.ImportSST/Compact", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) SetDownloadSpeedLimit(ctx context.Context, in *SetDownloadSpeedLimitRequest, opts ...grpc.CallOption) (*SetDownloadSpeedLimitResponse, error) {
	out := new(SetDownloadSpeedLimitResponse)
	err := c.cc.Invoke(ctx, "/import_sstpb.ImportSST/SetDownloadSpeedLimit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) Download(ctx context.Context, in *DownloadRequest, opts ...grpc.CallOption) (*DownloadResponse, error) {
	out := new(DownloadResponse)
	err := c.cc.Invoke(ctx, "/import_sstpb.ImportSST/Download", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) Write(ctx context.Context, opts ...grpc.CallOption) (ImportSST_WriteClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ImportSST_serviceDesc.Streams[1], "/import_sstpb.ImportSST/Write", opts...)
	if err != nil {
		return nil, err
	}
	x := &importSSTWriteClient{stream}
	return x, nil
}

type ImportSST_WriteClient interface {
	Send(*WriteRequest) error
	CloseAndRecv() (*WriteResponse, error)
	grpc.ClientStream
}

type importSSTWriteClient struct {
	grpc.ClientStream
}

func (x *importSSTWriteClient) Send(m *WriteRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *importSSTWriteClient) CloseAndRecv() (*WriteResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(WriteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *importSSTClient) RawWrite(ctx context.Context, opts ...grpc.CallOption) (ImportSST_RawWriteClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ImportSST_serviceDesc.Streams[2], "/import_sstpb.ImportSST/RawWrite", opts...)
	if err != nil {
		return nil, err
	}
	x := &importSSTRawWriteClient{stream}
	return x, nil
}

type ImportSST_RawWriteClient interface {
	Send(*RawWriteRequest) error
	CloseAndRecv() (*RawWriteResponse, error)
	grpc.ClientStream
}

type importSSTRawWriteClient struct {
	grpc.ClientStream
}

func (x *importSSTRawWriteClient) Send(m *RawWriteRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *importSSTRawWriteClient) CloseAndRecv() (*RawWriteResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(RawWriteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *importSSTClient) MultiIngest(ctx context.Context, in *MultiIngestRequest, opts ...grpc.CallOption) (*IngestResponse, error) {
	out := new(IngestResponse)
	err := c.cc.Invoke(ctx, "/import_sstpb.ImportSST/MultiIngest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *importSSTClient) DuplicateDetect(ctx context.Context, in *DuplicateDetectRequest, opts ...grpc.CallOption) (ImportSST_DuplicateDetectClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ImportSST_serviceDesc.Streams[3], "/import_sstpb.ImportSST/DuplicateDetect", opts...)
	if err != nil {
		return nil, err
	}
	x := &importSSTDuplicateDetectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ImportSST_DuplicateDetectClient interface {
	Recv() (*DuplicateDetectResponse, error)
	grpc.ClientStream
}

type importSSTDuplicateDetectClient struct {
	grpc.ClientStream
}

func (x *importSSTDuplicateDetectClient) Recv() (*DuplicateDetectResponse, error) {
	m := new(DuplicateDetectResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for ImportSST service

type ImportSSTServer interface {
	// Switch to normal/import mode.
	SwitchMode(context.Context, *SwitchModeRequest) (*SwitchModeResponse, error)
	// Upload an SST file to a server.
	Upload(ImportSST_UploadServer) error
	// Ingest an uploaded SST file to a region.
	Ingest(context.Context, *IngestRequest) (*IngestResponse, error)
	// Compact the specific range for better performance.
	Compact(context.Context, *CompactRequest) (*CompactResponse, error)
	SetDownloadSpeedLimit(context.Context, *SetDownloadSpeedLimitRequest) (*SetDownloadSpeedLimitResponse, error)
	// Download an SST file from an external storage, and performs key-rewrite
	// after downloading.
	Download(context.Context, *DownloadRequest) (*DownloadResponse, error)
	// Open a write stream to generate sst files
	Write(ImportSST_WriteServer) error
	RawWrite(ImportSST_RawWriteServer) error
	// Ingest Multiple files in one request
	MultiIngest(context.Context, *MultiIngestRequest) (*IngestResponse, error)
	// Collect duplicate data from TiKV.
	DuplicateDetect(*DuplicateDetectRequest, ImportSST_DuplicateDetectServer) error
}

func RegisterImportSSTServer(s *grpc.Server, srv ImportSSTServer) {
	s.RegisterService(&_ImportSST_serviceDesc, srv)
}

func _ImportSST_SwitchMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwitchModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).SwitchMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/import_sstpb.ImportSST/SwitchMode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).SwitchMode(ctx, req.(*SwitchModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_Upload_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ImportSSTServer).Upload(&importSSTUploadServer{stream})
}

type ImportSST_UploadServer interface {
	SendAndClose(*UploadResponse) error
	Recv() (*UploadRequest, error)
	grpc.ServerStream
}

type importSSTUploadServer struct {
	grpc.ServerStream
}

func (x *importSSTUploadServer) SendAndClose(m *UploadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *importSSTUploadServer) Recv() (*UploadRequest, error) {
	m := new(UploadRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ImportSST_Ingest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IngestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).Ingest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/import_sstpb.ImportSST/Ingest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).Ingest(ctx, req.(*IngestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_Compact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).Compact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/import_sstpb.ImportSST/Compact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).Compact(ctx, req.(*CompactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_SetDownloadSpeedLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDownloadSpeedLimitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).SetDownloadSpeedLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/import_sstpb.ImportSST/SetDownloadSpeedLimit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).SetDownloadSpeedLimit(ctx, req.(*SetDownloadSpeedLimitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_Download_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).Download(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/import_sstpb.ImportSST/Download",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).Download(ctx, req.(*DownloadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_Write_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ImportSSTServer).Write(&importSSTWriteServer{stream})
}

type ImportSST_WriteServer interface {
	SendAndClose(*WriteResponse) error
	Recv() (*WriteRequest, error)
	grpc.ServerStream
}

type importSSTWriteServer struct {
	grpc.ServerStream
}

func (x *importSSTWriteServer) SendAndClose(m *WriteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *importSSTWriteServer) Recv() (*WriteRequest, error) {
	m := new(WriteRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ImportSST_RawWrite_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ImportSSTServer).RawWrite(&importSSTRawWriteServer{stream})
}

type ImportSST_RawWriteServer interface {
	SendAndClose(*RawWriteResponse) error
	Recv() (*RawWriteRequest, error)
	grpc.ServerStream
}

type importSSTRawWriteServer struct {
	grpc.ServerStream
}

func (x *importSSTRawWriteServer) SendAndClose(m *RawWriteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *importSSTRawWriteServer) Recv() (*RawWriteRequest, error) {
	m := new(RawWriteRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _ImportSST_MultiIngest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MultiIngestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImportSSTServer).MultiIngest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/import_sstpb.ImportSST/MultiIngest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImportSSTServer).MultiIngest(ctx, req.(*MultiIngestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ImportSST_DuplicateDetect_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DuplicateDetectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ImportSSTServer).DuplicateDetect(m, &importSSTDuplicateDetectServer{stream})
}

type ImportSST_DuplicateDetectServer interface {
	Send(*DuplicateDetectResponse) error
	grpc.ServerStream
}

type importSSTDuplicateDetectServer struct {
	grpc.ServerStream
}

func (x *importSSTDuplicateDetectServer) Send(m *DuplicateDetectResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _ImportSST_serviceDesc = grpc.ServiceDesc{
	ServiceName: "import_sstpb.ImportSST",
	HandlerType: (*ImportSSTServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SwitchMode",
			Handler:    _ImportSST_SwitchMode_Handler,
		},
		{
			MethodName: "Ingest",
			Handler:    _ImportSST_Ingest_Handler,
		},
		{
			MethodName: "Compact",
			Handler:    _ImportSST_Compact_Handler,
		},
		{
			MethodName: "SetDownloadSpeedLimit",
			Handler:    _ImportSST_SetDownloadSpeedLimit_Handler,
		},
		{
			MethodName: "Download",
			Handler:    _ImportSST_Download_Handler,
		},
		{
			MethodName: "MultiIngest",
			Handler:    _ImportSST_MultiIngest_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Upload",
			Handler:       _ImportSST_Upload_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Write",
			Handler:       _ImportSST_Write_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "RawWrite",
			Handler:       _ImportSST_RawWrite_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "DuplicateDetect",
			Handler:       _ImportSST_DuplicateDetect_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "import_sstpb.proto",
}

func (m *SwitchModeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwitchModeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Mode))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SwitchModeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwitchModeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Start) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.Start)))
		i += copy(dAtA[i:], m.Start)
	}
	if len(m.End) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.End)))
		i += copy(dAtA[i:], m.End)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SSTMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SSTMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.Uuid)))
		i += copy(dAtA[i:], m.Uuid)
	}
	if m.Range != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Range.Size()))
		n1, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Crc32 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Crc32))
	}
	if m.Length != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Length))
	}
	if len(m.CfName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.CfName)))
		i += copy(dAtA[i:], m.CfName)
	}
	if m.RegionId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.RegionId))
	}
	if m.RegionEpoch != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.RegionEpoch.Size()))
		n2, err := m.RegionEpoch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.EndKeyExclusive {
		dAtA[i] = 0x40
		i++
		if m.EndKeyExclusive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TotalKvs != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.TotalKvs))
	}
	if m.TotalBytes != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.TotalBytes))
	}
	if m.ApiVersion != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.ApiVersion))
	}
	if len(m.CipherIv) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.CipherIv)))
		i += copy(dAtA[i:], m.CipherIv)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RewriteRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewriteRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OldKeyPrefix) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.OldKeyPrefix)))
		i += copy(dAtA[i:], m.OldKeyPrefix)
	}
	if len(m.NewKeyPrefix) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.NewKeyPrefix)))
		i += copy(dAtA[i:], m.NewKeyPrefix)
	}
	if m.NewTimestamp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.NewTimestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UploadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Chunk != nil {
		nn3, err := m.Chunk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UploadRequest_Meta) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Meta.Size()))
		n4, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}
func (m *UploadRequest_Data) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Data != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}
func (m *UploadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IngestRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngestRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Context.Size()))
		n5, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Sst != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Sst.Size()))
		n6, err := m.Sst.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *MultiIngestRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiIngestRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Context.Size()))
		n7, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Ssts) > 0 {
		for _, msg := range m.Ssts {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImportSstpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *IngestResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IngestResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Error.Size()))
		n8, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CompactRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Range != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Range.Size()))
		n9, err := m.Range.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.OutputLevel != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.OutputLevel))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CompactResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DownloadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintImportSstpb(dAtA, i, uint64(m.Sst.Size()))
	n10, err := m.Sst.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if len(m.Name) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	dAtA[i] = 0x6a
	i++
	i = encodeVarintImportSstpb(dAtA, i, uint64(m.RewriteRule.Size()))
	n11, err := m.RewriteRule.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	if m.StorageBackend != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.StorageBackend.Size()))
		n12, err := m.StorageBackend.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.IsRawKv {
		dAtA[i] = 0x78
		i++
		if m.IsRawKv {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CipherInfo != nil {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.CipherInfo.Size()))
		n13, err := m.CipherInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Error) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Error) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Message) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.Message)))
		i += copy(dAtA[i:], m.Message)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DownloadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DownloadResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintImportSstpb(dAtA, i, uint64(m.Range.Size()))
	n14, err := m.Range.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	if m.IsEmpty {
		dAtA[i] = 0x10
		i++
		if m.IsEmpty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Error != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Error.Size()))
		n15, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Crc32 != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Crc32))
	}
	if m.Length != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Length))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SetDownloadSpeedLimitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetDownloadSpeedLimitRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SpeedLimit != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.SpeedLimit))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SetDownloadSpeedLimitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetDownloadSpeedLimitResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Pair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.Op != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Op))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WriteBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CommitTs != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.CommitTs))
	}
	if len(m.Pairs) > 0 {
		for _, msg := range m.Pairs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImportSstpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WriteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Chunk != nil {
		nn16, err := m.Chunk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn16
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *WriteRequest_Meta) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Meta.Size()))
		n17, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}
func (m *WriteRequest_Batch) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Batch != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Batch.Size()))
		n18, err := m.Batch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func (m *WriteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WriteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Error.Size()))
		n19, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if len(m.Metas) > 0 {
		for _, msg := range m.Metas {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImportSstpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RawWriteBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawWriteBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ttl != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Ttl))
	}
	if len(m.Pairs) > 0 {
		for _, msg := range m.Pairs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImportSstpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RawWriteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawWriteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Chunk != nil {
		nn20, err := m.Chunk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn20
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RawWriteRequest_Meta) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Meta != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Meta.Size()))
		n21, err := m.Meta.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}
func (m *RawWriteRequest_Batch) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Batch != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Batch.Size()))
		n22, err := m.Batch.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}
func (m *RawWriteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawWriteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Error != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Error.Size()))
		n23, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if len(m.Metas) > 0 {
		for _, msg := range m.Metas {
			dAtA[i] = 0x12
			i++
			i = encodeVarintImportSstpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DuplicateDetectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DuplicateDetectRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.Context.Size()))
		n24, err := m.Context.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if len(m.StartKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	if m.KeyOnly {
		dAtA[i] = 0x20
		i++
		if m.KeyOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MinCommitTs != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.MinCommitTs))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KvPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KvPair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.CommitTs != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.CommitTs))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DuplicateDetectResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DuplicateDetectResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RegionError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.RegionError.Size()))
		n25, err := m.RegionError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.KeyError != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintImportSstpb(dAtA, i, uint64(m.KeyError.Size()))
		n26, err := m.KeyError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if len(m.Pairs) > 0 {
		for _, msg := range m.Pairs {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintImportSstpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintImportSstpb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SwitchModeRequest) Size() (n int) {
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovImportSstpb(uint64(m.Mode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SwitchModeResponse) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Range) Size() (n int) {
	var l int
	_ = l
	l = len(m.Start)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	l = len(m.End)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SSTMeta) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.Crc32 != 0 {
		n += 1 + sovImportSstpb(uint64(m.Crc32))
	}
	if m.Length != 0 {
		n += 1 + sovImportSstpb(uint64(m.Length))
	}
	l = len(m.CfName)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.RegionId != 0 {
		n += 1 + sovImportSstpb(uint64(m.RegionId))
	}
	if m.RegionEpoch != nil {
		l = m.RegionEpoch.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.EndKeyExclusive {
		n += 2
	}
	if m.TotalKvs != 0 {
		n += 1 + sovImportSstpb(uint64(m.TotalKvs))
	}
	if m.TotalBytes != 0 {
		n += 1 + sovImportSstpb(uint64(m.TotalBytes))
	}
	if m.ApiVersion != 0 {
		n += 1 + sovImportSstpb(uint64(m.ApiVersion))
	}
	l = len(m.CipherIv)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RewriteRule) Size() (n int) {
	var l int
	_ = l
	l = len(m.OldKeyPrefix)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	l = len(m.NewKeyPrefix)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.NewTimestamp != 0 {
		n += 1 + sovImportSstpb(uint64(m.NewTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadRequest) Size() (n int) {
	var l int
	_ = l
	if m.Chunk != nil {
		n += m.Chunk.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadRequest_Meta) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	return n
}
func (m *UploadRequest_Data) Size() (n int) {
	var l int
	_ = l
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	return n
}
func (m *UploadResponse) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IngestRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.Sst != nil {
		l = m.Sst.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MultiIngestRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if len(m.Ssts) > 0 {
		for _, e := range m.Ssts {
			l = e.Size()
			n += 1 + l + sovImportSstpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *IngestResponse) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CompactRequest) Size() (n int) {
	var l int
	_ = l
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.OutputLevel != 0 {
		n += 1 + sovImportSstpb(uint64(m.OutputLevel))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CompactResponse) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadRequest) Size() (n int) {
	var l int
	_ = l
	l = m.Sst.Size()
	n += 1 + l + sovImportSstpb(uint64(l))
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	l = m.RewriteRule.Size()
	n += 1 + l + sovImportSstpb(uint64(l))
	if m.StorageBackend != nil {
		l = m.StorageBackend.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.IsRawKv {
		n += 2
	}
	if m.CipherInfo != nil {
		l = m.CipherInfo.Size()
		n += 2 + l + sovImportSstpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Error) Size() (n int) {
	var l int
	_ = l
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DownloadResponse) Size() (n int) {
	var l int
	_ = l
	l = m.Range.Size()
	n += 1 + l + sovImportSstpb(uint64(l))
	if m.IsEmpty {
		n += 2
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.Crc32 != 0 {
		n += 1 + sovImportSstpb(uint64(m.Crc32))
	}
	if m.Length != 0 {
		n += 1 + sovImportSstpb(uint64(m.Length))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetDownloadSpeedLimitRequest) Size() (n int) {
	var l int
	_ = l
	if m.SpeedLimit != 0 {
		n += 1 + sovImportSstpb(uint64(m.SpeedLimit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetDownloadSpeedLimitResponse) Size() (n int) {
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Pair) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.Op != 0 {
		n += 1 + sovImportSstpb(uint64(m.Op))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WriteBatch) Size() (n int) {
	var l int
	_ = l
	if m.CommitTs != 0 {
		n += 1 + sovImportSstpb(uint64(m.CommitTs))
	}
	if len(m.Pairs) > 0 {
		for _, e := range m.Pairs {
			l = e.Size()
			n += 1 + l + sovImportSstpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WriteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Chunk != nil {
		n += m.Chunk.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WriteRequest_Meta) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	return n
}
func (m *WriteRequest_Batch) Size() (n int) {
	var l int
	_ = l
	if m.Batch != nil {
		l = m.Batch.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	return n
}
func (m *WriteResponse) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if len(m.Metas) > 0 {
		for _, e := range m.Metas {
			l = e.Size()
			n += 1 + l + sovImportSstpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RawWriteBatch) Size() (n int) {
	var l int
	_ = l
	if m.Ttl != 0 {
		n += 1 + sovImportSstpb(uint64(m.Ttl))
	}
	if len(m.Pairs) > 0 {
		for _, e := range m.Pairs {
			l = e.Size()
			n += 1 + l + sovImportSstpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RawWriteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Chunk != nil {
		n += m.Chunk.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RawWriteRequest_Meta) Size() (n int) {
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	return n
}
func (m *RawWriteRequest_Batch) Size() (n int) {
	var l int
	_ = l
	if m.Batch != nil {
		l = m.Batch.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	return n
}
func (m *RawWriteResponse) Size() (n int) {
	var l int
	_ = l
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if len(m.Metas) > 0 {
		for _, e := range m.Metas {
			l = e.Size()
			n += 1 + l + sovImportSstpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DuplicateDetectRequest) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.KeyOnly {
		n += 2
	}
	if m.MinCommitTs != 0 {
		n += 1 + sovImportSstpb(uint64(m.MinCommitTs))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KvPair) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.CommitTs != 0 {
		n += 1 + sovImportSstpb(uint64(m.CommitTs))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DuplicateDetectResponse) Size() (n int) {
	var l int
	_ = l
	if m.RegionError != nil {
		l = m.RegionError.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if m.KeyError != nil {
		l = m.KeyError.Size()
		n += 1 + l + sovImportSstpb(uint64(l))
	}
	if len(m.Pairs) > 0 {
		for _, e := range m.Pairs {
			l = e.Size()
			n += 1 + l + sovImportSstpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovImportSstpb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozImportSstpb(x uint64) (n int) {
	return sovImportSstpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SwitchModeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwitchModeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwitchModeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= (SwitchMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwitchModeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwitchModeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwitchModeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Start = append(m.Start[:0], dAtA[iNdEx:postIndex]...)
			if m.Start == nil {
				m.Start = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = append(m.End[:0], dAtA[iNdEx:postIndex]...)
			if m.End == nil {
				m.End = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SSTMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SSTMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SSTMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = append(m.Uuid[:0], dAtA[iNdEx:postIndex]...)
			if m.Uuid == nil {
				m.Uuid = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crc32", wireType)
			}
			m.Crc32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Crc32 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CfName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionId", wireType)
			}
			m.RegionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegionId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionEpoch == nil {
				m.RegionEpoch = &metapb.RegionEpoch{}
			}
			if err := m.RegionEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKeyExclusive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EndKeyExclusive = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalKvs", wireType)
			}
			m.TotalKvs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalKvs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBytes", wireType)
			}
			m.TotalBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			m.ApiVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiVersion |= (kvrpcpb.APIVersion(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherIv", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CipherIv = append(m.CipherIv[:0], dAtA[iNdEx:postIndex]...)
			if m.CipherIv == nil {
				m.CipherIv = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewriteRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewriteRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewriteRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldKeyPrefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldKeyPrefix = append(m.OldKeyPrefix[:0], dAtA[iNdEx:postIndex]...)
			if m.OldKeyPrefix == nil {
				m.OldKeyPrefix = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewKeyPrefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewKeyPrefix = append(m.NewKeyPrefix[:0], dAtA[iNdEx:postIndex]...)
			if m.NewKeyPrefix == nil {
				m.NewKeyPrefix = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTimestamp", wireType)
			}
			m.NewTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewTimestamp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SSTMeta{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Chunk = &UploadRequest_Meta{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Chunk = &UploadRequest_Data{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngestRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &kvrpcpb.Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sst", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sst == nil {
				m.Sst = &SSTMeta{}
			}
			if err := m.Sst.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiIngestRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiIngestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiIngestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &kvrpcpb.Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ssts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ssts = append(m.Ssts, &SSTMeta{})
			if err := m.Ssts[len(m.Ssts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &errorpb.Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &Range{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputLevel", wireType)
			}
			m.OutputLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutputLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sst", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Sst.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewriteRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RewriteRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageBackend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageBackend == nil {
				m.StorageBackend = &brpb.StorageBackend{}
			}
			if err := m.StorageBackend.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRawKv", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRawKv = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CipherInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CipherInfo == nil {
				m.CipherInfo = &brpb.CipherInfo{}
			}
			if err := m.CipherInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Error) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DownloadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DownloadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DownloadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEmpty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEmpty = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crc32", wireType)
			}
			m.Crc32 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Crc32 |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetDownloadSpeedLimitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetDownloadSpeedLimitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetDownloadSpeedLimitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpeedLimit", wireType)
			}
			m.SpeedLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpeedLimit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetDownloadSpeedLimitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetDownloadSpeedLimitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetDownloadSpeedLimitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (Pair_OP(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			m.CommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pairs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pairs = append(m.Pairs, &Pair{})
			if err := m.Pairs[len(m.Pairs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SSTMeta{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Chunk = &WriteRequest_Meta{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &WriteBatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Chunk = &WriteRequest_Batch{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metas = append(m.Metas, &SSTMeta{})
			if err := m.Metas[len(m.Metas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawWriteBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawWriteBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawWriteBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ttl", wireType)
			}
			m.Ttl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ttl |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pairs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pairs = append(m.Pairs, &Pair{})
			if err := m.Pairs[len(m.Pairs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawWriteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawWriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawWriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SSTMeta{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Chunk = &RawWriteRequest_Meta{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RawWriteBatch{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Chunk = &RawWriteRequest_Batch{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawWriteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawWriteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawWriteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &Error{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metas = append(m.Metas, &SSTMeta{})
			if err := m.Metas[len(m.Metas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DuplicateDetectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DuplicateDetectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DuplicateDetectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &kvrpcpb.Context{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyOnly = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinCommitTs", wireType)
			}
			m.MinCommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinCommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KvPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KvPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KvPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTs", wireType)
			}
			m.CommitTs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitTs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DuplicateDetectResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DuplicateDetectResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DuplicateDetectResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegionError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegionError == nil {
				m.RegionError = &errorpb.Error{}
			}
			if err := m.RegionError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyError == nil {
				m.KeyError = &Error{}
			}
			if err := m.KeyError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pairs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthImportSstpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pairs = append(m.Pairs, &KvPair{})
			if err := m.Pairs[len(m.Pairs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipImportSstpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthImportSstpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipImportSstpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowImportSstpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowImportSstpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthImportSstpb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowImportSstpb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipImportSstpb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthImportSstpb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowImportSstpb   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("import_sstpb.proto", fileDescriptor_import_sstpb_84cbfa235a106715) }

var fileDescriptor_import_sstpb_84cbfa235a106715 = []byte{
	// 1536 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0x49, 0x6f, 0x1c, 0xc7,
	0x15, 0x66, 0x73, 0xf6, 0x37, 0xab, 0x4a, 0x94, 0xd4, 0x1a, 0x4a, 0x24, 0xd5, 0xa1, 0x12, 0x8a,
	0x4a, 0x46, 0x0a, 0x19, 0xe8, 0x2a, 0x88, 0x0b, 0x22, 0x86, 0xa2, 0xc8, 0xd4, 0x30, 0xc9, 0x21,
	0x40, 0x1a, 0xcd, 0x9e, 0xe2, 0xb0, 0x33, 0xbd, 0xa5, 0xab, 0xba, 0x47, 0x03, 0x04, 0xfe, 0x1d,
	0xbe, 0xfa, 0x66, 0xf8, 0x6e, 0x18, 0x3e, 0xfb, 0xa2, 0xa3, 0x8f, 0x3e, 0x19, 0x86, 0xfc, 0x47,
	0x8c, 0x5a, 0x7a, 0x96, 0xd6, 0x90, 0xb4, 0x08, 0xf8, 0x34, 0xf5, 0x96, 0x7a, 0xef, 0xf5, 0x5b,
	0xbe, 0x7a, 0x03, 0xc8, 0xf1, 0xc2, 0x20, 0x62, 0x26, 0xa5, 0x2c, 0x3c, 0xeb, 0x84, 0x51, 0xc0,
	0x02, 0x54, 0x9b, 0xe6, 0xb5, 0x6b, 0x1e, 0x61, 0x56, 0x2a, 0x6b, 0xd7, 0x49, 0x14, 0x05, 0xd1,
	0x84, 0x1c, 0x24, 0x51, 0x68, 0x8f, 0xc9, 0xdb, 0x91, 0x75, 0xce, 0x4c, 0x4a, 0xa2, 0x84, 0x4c,
	0x74, 0x96, 0xfa, 0x41, 0x3f, 0x10, 0xc7, 0x67, 0xfc, 0xa4, 0xb8, 0xcd, 0x28, 0xa6, 0x4c, 0x1c,
	0x15, 0x03, 0xce, 0xc6, 0x57, 0x8c, 0x57, 0x70, 0xab, 0x3b, 0x74, 0x98, 0x7d, 0x71, 0x14, 0xf4,
	0x08, 0x26, 0xff, 0x8b, 0x09, 0x65, 0xe8, 0x8f, 0x90, 0xf7, 0x82, 0x1e, 0xd1, 0xb5, 0x35, 0x6d,
	0xa3, 0xb1, 0xa5, 0x77, 0x66, 0x22, 0x9f, 0x52, 0x17, 0x5a, 0xc6, 0x12, 0xa0, 0x69, 0x13, 0x34,
	0x0c, 0x7c, 0x4a, 0x8c, 0x67, 0x50, 0xc0, 0x96, 0xdf, 0x27, 0x68, 0x09, 0x0a, 0x94, 0x59, 0x11,
	0x13, 0xd6, 0x6a, 0x58, 0x12, 0xa8, 0x05, 0x39, 0xe2, 0xf7, 0xf4, 0x45, 0xc1, 0xe3, 0x47, 0xe3,
	0x8b, 0x1c, 0x94, 0xba, 0xdd, 0xd3, 0x23, 0xc2, 0x2c, 0x84, 0x20, 0x1f, 0xc7, 0x4e, 0x4f, 0x5d,
	0x11, 0x67, 0xf4, 0x04, 0x0a, 0x11, 0x37, 0x28, 0xee, 0x54, 0xb7, 0x6e, 0xcf, 0x46, 0x25, 0x7c,
	0x61, 0xa9, 0xc1, 0x5d, 0xda, 0x91, 0xbd, 0xbd, 0xa5, 0xe7, 0xd6, 0xb4, 0x8d, 0x3a, 0x96, 0x04,
	0xba, 0x0b, 0x45, 0x97, 0xf8, 0x7d, 0x76, 0xa1, 0xe7, 0xd7, 0xb4, 0x8d, 0x3c, 0x56, 0x14, 0xba,
	0x07, 0x25, 0xfb, 0xdc, 0xf4, 0x2d, 0x8f, 0xe8, 0x85, 0x35, 0x6d, 0xa3, 0x82, 0x8b, 0xf6, 0xf9,
	0x5b, 0xcb, 0x23, 0x68, 0x19, 0x2a, 0x11, 0xe9, 0x3b, 0x81, 0x6f, 0x3a, 0x3d, 0xbd, 0x28, 0xee,
	0x94, 0x25, 0xe3, 0xa0, 0x87, 0x5e, 0x40, 0x4d, 0x09, 0x49, 0x18, 0xd8, 0x17, 0x7a, 0x49, 0x45,
	0xa5, 0x6a, 0x88, 0x85, 0x6c, 0x9f, 0x8b, 0x70, 0x35, 0x9a, 0x10, 0x68, 0x13, 0x6e, 0x11, 0xbf,
	0x67, 0x0e, 0xc8, 0xc8, 0x24, 0xef, 0x6c, 0x37, 0xa6, 0x4e, 0x42, 0xf4, 0xf2, 0x9a, 0xb6, 0x51,
	0xc6, 0x4d, 0xe2, 0xf7, 0x0e, 0xc9, 0x68, 0x3f, 0x65, 0xf3, 0x00, 0x58, 0xc0, 0x2c, 0xd7, 0x1c,
	0x24, 0x54, 0xaf, 0xc8, 0x00, 0x04, 0xe3, 0x30, 0xa1, 0x68, 0x15, 0xaa, 0x52, 0x78, 0x36, 0x62,
	0x84, 0xea, 0x20, 0xc4, 0x20, 0x58, 0x3b, 0x9c, 0x83, 0xfe, 0x02, 0x55, 0x2b, 0x74, 0xcc, 0x84,
	0x44, 0xd4, 0x09, 0x7c, 0xbd, 0x2a, 0x8a, 0x79, 0xbb, 0x93, 0xf6, 0xd1, 0xab, 0x93, 0x83, 0x7f,
	0x4a, 0x11, 0x06, 0x2b, 0x74, 0xd4, 0x99, 0xfb, 0xb4, 0x9d, 0xf0, 0x82, 0x44, 0xa6, 0x93, 0xe8,
	0x35, 0x91, 0xff, 0xb2, 0x64, 0x1c, 0x24, 0xc6, 0x67, 0x50, 0xc5, 0x64, 0x18, 0x39, 0x8c, 0xe0,
	0xd8, 0x25, 0x68, 0x1d, 0x1a, 0x81, 0x2b, 0xbf, 0x25, 0x8c, 0xc8, 0xb9, 0xf3, 0x4e, 0x15, 0xac,
	0x16, 0xb8, 0xfc, 0x43, 0x4e, 0x04, 0x8f, 0x6b, 0xf9, 0x64, 0x38, 0xad, 0x25, 0xab, 0x5e, 0xf3,
	0xc9, 0x70, 0xa2, 0xf5, 0x3b, 0xa8, 0x73, 0x2d, 0xe6, 0x78, 0x84, 0x32, 0xcb, 0x0b, 0x45, 0xed,
	0xf2, 0x42, 0xe9, 0x34, 0xe5, 0x19, 0xff, 0x86, 0xfa, 0x3f, 0x42, 0x37, 0xb0, 0x7a, 0x69, 0xa7,
	0x3e, 0x85, 0x3c, 0x4f, 0xb8, 0xf0, 0x5b, 0xdd, 0xba, 0x93, 0xe9, 0x54, 0xd9, 0x4d, 0xaf, 0x17,
	0xb0, 0x50, 0x42, 0x4b, 0x90, 0xef, 0x59, 0xcc, 0x92, 0xee, 0x39, 0x97, 0x53, 0x3b, 0x25, 0x28,
	0xd8, 0x17, 0xb1, 0x3f, 0x30, 0x5a, 0xd0, 0x48, 0x8d, 0xab, 0x1e, 0xee, 0x41, 0xfd, 0xc0, 0xef,
	0x13, 0xca, 0x52, 0x77, 0x9b, 0x50, 0xb2, 0x03, 0x9f, 0x91, 0x77, 0x4c, 0x79, 0x6c, 0x8d, 0xd3,
	0xb9, 0x2b, 0xf9, 0x38, 0x55, 0x40, 0x7f, 0x80, 0x1c, 0xa5, 0x4c, 0x75, 0xeb, 0xfc, 0xc8, 0x30,
	0xd7, 0x30, 0x06, 0x80, 0x8e, 0x62, 0x97, 0x39, 0x37, 0x77, 0xf5, 0x04, 0xf2, 0x94, 0x32, 0xaa,
	0x2f, 0xae, 0xe5, 0x2e, 0xf7, 0x25, 0x54, 0x8c, 0x17, 0xd0, 0x48, 0xfd, 0xc8, 0x8f, 0x44, 0xeb,
	0x50, 0x10, 0x48, 0xa3, 0xdc, 0x34, 0x3a, 0x29, 0xee, 0xec, 0xf3, 0x5f, 0x2c, 0x85, 0xc6, 0x7f,
	0xa0, 0xb1, 0x1b, 0x78, 0xa1, 0x65, 0x8f, 0x03, 0x1c, 0xcf, 0xa3, 0x76, 0xed, 0x3c, 0x3e, 0x82,
	0x5a, 0x10, 0xb3, 0x30, 0x66, 0xa6, 0x4b, 0x12, 0xe2, 0x8a, 0x9c, 0x14, 0x70, 0x55, 0xf2, 0xde,
	0x70, 0x96, 0x71, 0x0b, 0x9a, 0x63, 0xfb, 0x2a, 0xfb, 0x5f, 0x2f, 0x42, 0x73, 0x2f, 0x18, 0xfa,
	0xd3, 0xf5, 0xfe, 0xd3, 0xf5, 0x49, 0xdd, 0xc9, 0xbf, 0xff, 0x71, 0x75, 0x41, 0xa4, 0x96, 0xe3,
	0x88, 0x98, 0xeb, 0x8a, 0x98, 0x6b, 0x71, 0x46, 0x3b, 0x7c, 0x70, 0x45, 0x0f, 0x9b, 0x51, 0xec,
	0x12, 0xbd, 0x2e, 0x6c, 0xdd, 0xcf, 0x84, 0x3f, 0xe9, 0x72, 0x65, 0xaf, 0x1a, 0x4d, 0x35, 0xfe,
	0x4b, 0x68, 0x52, 0x16, 0x44, 0x56, 0x9f, 0x98, 0x67, 0x96, 0x3d, 0xe0, 0x48, 0xd6, 0x10, 0x66,
	0xee, 0x76, 0x38, 0x1d, 0x87, 0x9d, 0xae, 0x14, 0xef, 0x48, 0x29, 0x6e, 0xd0, 0x19, 0x1a, 0xb5,
	0xa1, 0xe2, 0x50, 0x33, 0xb2, 0x86, 0xe6, 0x20, 0xd1, 0x9b, 0x62, 0xfa, 0x4b, 0x0e, 0xc5, 0xd6,
	0xf0, 0x30, 0x41, 0xdb, 0x50, 0x4d, 0x27, 0xd0, 0x3f, 0x0f, 0xf4, 0x96, 0x30, 0x8c, 0x52, 0xc3,
	0xbb, 0x72, 0x16, 0xfd, 0xf3, 0x00, 0x83, 0x3d, 0x3e, 0xff, 0x2d, 0x5f, 0x2e, 0xb7, 0x2a, 0x38,
	0x17, 0x47, 0xae, 0xf1, 0x08, 0x0a, 0xa2, 0x74, 0x48, 0x87, 0x92, 0x47, 0x28, 0xb5, 0x54, 0x8d,
	0x2a, 0x38, 0x25, 0x8d, 0x6f, 0x34, 0x68, 0x4d, 0x52, 0xab, 0x1a, 0xe1, 0xd9, 0xf5, 0x05, 0x55,
	0xb9, 0x50, 0x65, 0xbd, 0x0f, 0x65, 0x87, 0x9a, 0xc4, 0x0b, 0xd9, 0x48, 0x54, 0x44, 0x7c, 0xc3,
	0x3e, 0x27, 0x79, 0x73, 0xc8, 0xa6, 0xca, 0xcd, 0xb3, 0x35, 0xdd, 0x59, 0x13, 0xb0, 0xce, 0xcf,
	0x07, 0xeb, 0xc2, 0x34, 0x58, 0x1b, 0x2f, 0xe1, 0x41, 0x97, 0xb0, 0x34, 0xf6, 0x6e, 0x48, 0x48,
	0xef, 0x8d, 0xe3, 0x39, 0xe3, 0xae, 0x5c, 0x85, 0x2a, 0xe5, 0x4c, 0xd3, 0xe5, 0x5c, 0xf1, 0x29,
	0x79, 0x0c, 0x74, 0xac, 0x67, 0xac, 0xc2, 0xc3, 0x4b, 0x0c, 0xa8, 0xb6, 0x0b, 0x21, 0x7f, 0x62,
	0x39, 0x11, 0x7f, 0xa1, 0x06, 0x64, 0xa4, 0x10, 0x8d, 0x1f, 0x79, 0xa4, 0x89, 0xe5, 0xc6, 0x44,
	0xe1, 0x97, 0x24, 0xd0, 0x63, 0x58, 0x0c, 0x24, 0x5a, 0x35, 0xb2, 0x1d, 0xc9, 0xed, 0x74, 0x8e,
	0x4f, 0xf0, 0x62, 0x10, 0x1a, 0xf7, 0x61, 0xf1, 0xf8, 0x04, 0x95, 0x20, 0x77, 0x12, 0xb3, 0xd6,
	0x02, 0x02, 0x28, 0xee, 0x11, 0x97, 0x30, 0xd2, 0xd2, 0x8c, 0x2e, 0xc0, 0xbf, 0x78, 0x6b, 0xed,
	0x58, 0xcc, 0xbe, 0x10, 0x00, 0x1c, 0x78, 0x9e, 0xc3, 0x4c, 0x46, 0x55, 0xfc, 0x65, 0xc9, 0x38,
	0xa5, 0x68, 0x03, 0x0a, 0xa1, 0xe5, 0x44, 0xe9, 0xa8, 0xa3, 0x8f, 0xfd, 0x61, 0xa9, 0x60, 0x24,
	0x50, 0x13, 0x46, 0x6f, 0x84, 0x94, 0xcf, 0xa1, 0x70, 0xc6, 0x83, 0x51, 0x83, 0x96, 0xd9, 0x00,
	0x26, 0xc1, 0xbe, 0x5e, 0xc0, 0x52, 0x71, 0x82, 0xa2, 0x7d, 0xa8, 0x2b, 0xbf, 0xaa, 0xad, 0x9e,
	0xcc, 0xe2, 0xcb, 0x55, 0xad, 0xf0, 0x14, 0x0a, 0xdc, 0xfd, 0x35, 0x40, 0x26, 0x75, 0x8c, 0x43,
	0xa8, 0x63, 0x6b, 0x38, 0x95, 0xb8, 0x16, 0xe4, 0x18, 0x73, 0x55, 0xca, 0xf8, 0xf1, 0x13, 0xb2,
	0xf5, 0x7f, 0x68, 0xa6, 0xc6, 0x6e, 0x94, 0xb0, 0xed, 0xd9, 0x84, 0x2d, 0x67, 0x67, 0x67, 0x78,
	0x65, 0xce, 0xfe, 0x0b, 0xad, 0x89, 0xf7, 0xdf, 0x38, 0x6d, 0xdf, 0x6a, 0x70, 0x77, 0x2f, 0x0e,
	0x5d, 0xc7, 0xb6, 0x18, 0xd9, 0x23, 0x8c, 0xd8, 0x37, 0x7a, 0x72, 0x96, 0xa1, 0x22, 0x16, 0x39,
	0xfe, 0xac, 0xab, 0x79, 0x28, 0x0b, 0xc6, 0x21, 0x19, 0xf1, 0x8d, 0x4a, 0xed, 0x38, 0x62, 0x2e,
	0x6a, 0xb8, 0x28, 0x37, 0x1b, 0x8e, 0x18, 0x7c, 0x0d, 0x08, 0x7c, 0x77, 0x24, 0xc6, 0xbd, 0x8c,
	0x4b, 0x03, 0x32, 0x3a, 0xf6, 0xdd, 0x11, 0x32, 0xa0, 0xee, 0x39, 0xbe, 0x39, 0x69, 0x7d, 0x39,
	0xf7, 0x55, 0xcf, 0xf1, 0x77, 0x55, 0xf7, 0x1b, 0x47, 0x50, 0x3c, 0x4c, 0x3e, 0x69, 0x38, 0x67,
	0x86, 0x29, 0x37, 0x3b, 0x4c, 0xc6, 0x57, 0x1a, 0xdc, 0xfb, 0x28, 0x15, 0x2a, 0xfd, 0x7f, 0x9e,
	0xac, 0x77, 0x57, 0x3c, 0x8e, 0xe9, 0x66, 0x27, 0xca, 0xf0, 0x1c, 0x2a, 0x62, 0xab, 0x13, 0xfa,
	0x8b, 0x97, 0x57, 0x8d, 0xa7, 0x40, 0xde, 0xd8, 0x4c, 0xfb, 0x33, 0x27, 0x0a, 0xb7, 0x34, 0xab,
	0x2d, 0x3f, 0x55, 0x75, 0xe8, 0xe6, 0x3a, 0xc0, 0x64, 0xcb, 0xe6, 0xf0, 0xf1, 0x36, 0x88, 0x3c,
	0xcb, 0x95, 0x50, 0x72, 0x20, 0xee, 0xb5, 0xb4, 0xad, 0xef, 0x8a, 0x50, 0x91, 0x44, 0xb7, 0x7b,
	0x8a, 0xfe, 0x3e, 0x73, 0x67, 0xf5, 0xd2, 0x3d, 0x5e, 0xd6, 0xbf, 0xbd, 0x76, 0xb9, 0x82, 0xc2,
	0xc6, 0x05, 0xf4, 0x57, 0x28, 0xca, 0x25, 0x09, 0x65, 0x7a, 0x7c, 0x66, 0x2f, 0x6b, 0x3f, 0x98,
	0x2f, 0x4c, 0xcd, 0x6c, 0x68, 0x68, 0x1f, 0x8a, 0x72, 0x11, 0xc9, 0x1a, 0x9a, 0x59, 0x83, 0xb2,
	0x86, 0x66, 0x77, 0x17, 0x63, 0x01, 0xbd, 0x86, 0x92, 0xda, 0x1b, 0x50, 0x46, 0x75, 0x76, 0x5d,
	0x69, 0x3f, 0xbc, 0x44, 0x3a, 0xb6, 0x14, 0xc1, 0x9d, 0xb9, 0x0f, 0x03, 0xda, 0xcc, 0xa4, 0xe5,
	0x8a, 0xe7, 0xa7, 0xfd, 0xf4, 0x57, 0xe9, 0x8e, 0x7d, 0x1e, 0x42, 0x39, 0x95, 0xa3, 0x4c, 0x80,
	0x99, 0xcd, 0xa7, 0xbd, 0x72, 0x99, 0x78, 0x6c, 0x6c, 0x0f, 0x0a, 0x02, 0x42, 0x50, 0x7b, 0x0e,
	0x5c, 0xa7, 0x66, 0x96, 0xe7, 0xca, 0xa6, 0xea, 0x72, 0x04, 0xe5, 0x14, 0x8b, 0xb2, 0x21, 0x65,
	0x10, 0x32, 0x1b, 0x52, 0x16, 0xc2, 0x84, 0xb9, 0x63, 0xa8, 0x4e, 0x2d, 0xb7, 0x28, 0xd3, 0x62,
	0x1f, 0xef, 0xbd, 0xd7, 0x16, 0xfc, 0x0c, 0x9a, 0x99, 0x99, 0x45, 0xeb, 0x99, 0xd4, 0xcc, 0x45,
	0xb7, 0xf6, 0xe3, 0x6b, 0xb4, 0x52, 0x0f, 0xcf, 0xb5, 0x9d, 0xdf, 0xff, 0xf0, 0x65, 0x59, 0x7b,
	0xff, 0x61, 0x45, 0xfb, 0xfe, 0xc3, 0x8a, 0xf6, 0xd3, 0x87, 0x15, 0xed, 0xf3, 0x9f, 0x57, 0x16,
	0xa0, 0x15, 0x44, 0xfd, 0x0e, 0x73, 0x06, 0x49, 0x67, 0x90, 0x88, 0x3f, 0xcf, 0x67, 0x45, 0xf1,
	0xb3, 0xfd, 0x4b, 0x00, 0x00, 0x00, 0xff, 0xff, 0x6d, 0x0b, 0x1a, 0x5d, 0xdb, 0x0f, 0x00, 0x00,
}
